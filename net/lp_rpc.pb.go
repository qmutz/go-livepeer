// Code generated by protoc-gen-go. DO NOT EDIT.
// source: net/lp_rpc.proto

/*
Package net is a generated protocol buffer package.

It is generated from these files:
	net/lp_rpc.proto

It has these top-level messages:
	PingPong
	OrchestratorRequest
	OSInfo
	S3OSInfo
	OrchestratorInfo
	SegData
	TranscodedSegmentData
	TranscodeData
	TranscodeResult
	RegisterRequest
	NotifySegment
	TicketParams
	Ticket
	Payment
*/
package net

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type OSInfo_StorageType int32

const (
	OSInfo_DIRECT OSInfo_StorageType = 0
	OSInfo_S3     OSInfo_StorageType = 1
	OSInfo_IPFS   OSInfo_StorageType = 2
	OSInfo_GOOGLE OSInfo_StorageType = 3
)

var OSInfo_StorageType_name = map[int32]string{
	0: "DIRECT",
	1: "S3",
	2: "IPFS",
	3: "GOOGLE",
}
var OSInfo_StorageType_value = map[string]int32{
	"DIRECT": 0,
	"S3":     1,
	"IPFS":   2,
	"GOOGLE": 3,
}

func (x OSInfo_StorageType) String() string {
	return proto.EnumName(OSInfo_StorageType_name, int32(x))
}
func (OSInfo_StorageType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2, 0} }

type PingPong struct {
	// Implementation defined
	Value []byte `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *PingPong) Reset()                    { *m = PingPong{} }
func (m *PingPong) String() string            { return proto.CompactTextString(m) }
func (*PingPong) ProtoMessage()               {}
func (*PingPong) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *PingPong) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

// This request is sent by the broadcaster in `GetTranscoder` to request
// information on which transcoder to use.
type OrchestratorRequest struct {
	// Ethereum address of the broadcaster
	Address []byte `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// Broadcaster's signature over its address
	Sig []byte `protobuf:"bytes,2,opt,name=sig,proto3" json:"sig,omitempty"`
}

func (m *OrchestratorRequest) Reset()                    { *m = OrchestratorRequest{} }
func (m *OrchestratorRequest) String() string            { return proto.CompactTextString(m) }
func (*OrchestratorRequest) ProtoMessage()               {}
func (*OrchestratorRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *OrchestratorRequest) GetAddress() []byte {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *OrchestratorRequest) GetSig() []byte {
	if m != nil {
		return m.Sig
	}
	return nil
}

//
// OSInfo needed to negotiate storages that will be used.
// It carries info needed to write to the storage.
type OSInfo struct {
	// Storage type: direct, s3, ipfs.
	StorageType OSInfo_StorageType `protobuf:"varint,1,opt,name=storageType,enum=net.OSInfo_StorageType" json:"storageType,omitempty"`
	S3Info      *S3OSInfo          `protobuf:"bytes,16,opt,name=s3info" json:"s3info,omitempty"`
}

func (m *OSInfo) Reset()                    { *m = OSInfo{} }
func (m *OSInfo) String() string            { return proto.CompactTextString(m) }
func (*OSInfo) ProtoMessage()               {}
func (*OSInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *OSInfo) GetStorageType() OSInfo_StorageType {
	if m != nil {
		return m.StorageType
	}
	return OSInfo_DIRECT
}

func (m *OSInfo) GetS3Info() *S3OSInfo {
	if m != nil {
		return m.S3Info
	}
	return nil
}

type S3OSInfo struct {
	// Host to use to connect to S3
	Host string `protobuf:"bytes,1,opt,name=host" json:"host,omitempty"`
	// Key (prefix) to use when uploading the object.
	Key string `protobuf:"bytes,2,opt,name=key" json:"key,omitempty"`
	// POST policy that S3 owner node creates to give write access to other node.
	Policy string `protobuf:"bytes,3,opt,name=policy" json:"policy,omitempty"`
	// Signature for POST policy.
	Signature string `protobuf:"bytes,4,opt,name=signature" json:"signature,omitempty"`
	// Needed for POST policy.
	Credential string `protobuf:"bytes,5,opt,name=credential" json:"credential,omitempty"`
	// Needed for POST policy.
	XAmzDate string `protobuf:"bytes,6,opt,name=xAmzDate" json:"xAmzDate,omitempty"`
}

func (m *S3OSInfo) Reset()                    { *m = S3OSInfo{} }
func (m *S3OSInfo) String() string            { return proto.CompactTextString(m) }
func (*S3OSInfo) ProtoMessage()               {}
func (*S3OSInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *S3OSInfo) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *S3OSInfo) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *S3OSInfo) GetPolicy() string {
	if m != nil {
		return m.Policy
	}
	return ""
}

func (m *S3OSInfo) GetSignature() string {
	if m != nil {
		return m.Signature
	}
	return ""
}

func (m *S3OSInfo) GetCredential() string {
	if m != nil {
		return m.Credential
	}
	return ""
}

func (m *S3OSInfo) GetXAmzDate() string {
	if m != nil {
		return m.XAmzDate
	}
	return ""
}

// The orchestrator sends this in response to `GetOrchestrator`, containing
// miscellaneous data related to the job.
type OrchestratorInfo struct {
	// URI of the transcoder to use for submitting segments.
	Transcoder string `protobuf:"bytes,1,opt,name=transcoder" json:"transcoder,omitempty"`
	// Parameters for probabilistic micropayment tickets
	TicketParams *TicketParams `protobuf:"bytes,2,opt,name=ticket_params,json=ticketParams" json:"ticket_params,omitempty"`
	// Orchestrator returns info about own input object storage, if it wants it to be used.
	Storage []*OSInfo `protobuf:"bytes,32,rep,name=storage" json:"storage,omitempty"`
}

func (m *OrchestratorInfo) Reset()                    { *m = OrchestratorInfo{} }
func (m *OrchestratorInfo) String() string            { return proto.CompactTextString(m) }
func (*OrchestratorInfo) ProtoMessage()               {}
func (*OrchestratorInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *OrchestratorInfo) GetTranscoder() string {
	if m != nil {
		return m.Transcoder
	}
	return ""
}

func (m *OrchestratorInfo) GetTicketParams() *TicketParams {
	if m != nil {
		return m.TicketParams
	}
	return nil
}

func (m *OrchestratorInfo) GetStorage() []*OSInfo {
	if m != nil {
		return m.Storage
	}
	return nil
}

// Data included by the broadcaster when submitting a segment for transcoding.
type SegData struct {
	// Manifest ID this segment belongs to
	ManifestId []byte `protobuf:"bytes,1,opt,name=manifestId,proto3" json:"manifestId,omitempty"`
	// Sequence number of the segment to be transcoded
	Seq int64 `protobuf:"varint,2,opt,name=seq" json:"seq,omitempty"`
	// Hash of the segment data to be transcoded
	Hash []byte `protobuf:"bytes,3,opt,name=hash,proto3" json:"hash,omitempty"`
	// Transcoding profiles to use
	Profiles []byte `protobuf:"bytes,4,opt,name=profiles,proto3" json:"profiles,omitempty"`
	// Broadcaster signature for the segment. Corresponds to:
	// broadcaster.sign(manifestId | seqNo | dataHash | profiles)
	Sig []byte `protobuf:"bytes,5,opt,name=sig,proto3" json:"sig,omitempty"`
	// Broadcaster's preferred storage medium(s)
	// XXX should we include this in a sig somewhere until certs are authenticated?
	Storage []*OSInfo `protobuf:"bytes,32,rep,name=storage" json:"storage,omitempty"`
}

func (m *SegData) Reset()                    { *m = SegData{} }
func (m *SegData) String() string            { return proto.CompactTextString(m) }
func (*SegData) ProtoMessage()               {}
func (*SegData) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *SegData) GetManifestId() []byte {
	if m != nil {
		return m.ManifestId
	}
	return nil
}

func (m *SegData) GetSeq() int64 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *SegData) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

func (m *SegData) GetProfiles() []byte {
	if m != nil {
		return m.Profiles
	}
	return nil
}

func (m *SegData) GetSig() []byte {
	if m != nil {
		return m.Sig
	}
	return nil
}

func (m *SegData) GetStorage() []*OSInfo {
	if m != nil {
		return m.Storage
	}
	return nil
}

// Individual transcoded segment data.
type TranscodedSegmentData struct {
	// URL where the transcoded data can be downloaded from.
	Url string `protobuf:"bytes,1,opt,name=url" json:"url,omitempty"`
}

func (m *TranscodedSegmentData) Reset()                    { *m = TranscodedSegmentData{} }
func (m *TranscodedSegmentData) String() string            { return proto.CompactTextString(m) }
func (*TranscodedSegmentData) ProtoMessage()               {}
func (*TranscodedSegmentData) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *TranscodedSegmentData) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

// A set of transcoded segments following the profiles specified in the job.
type TranscodeData struct {
	// Transcoded data, in the order specified in the job options
	Segments []*TranscodedSegmentData `protobuf:"bytes,1,rep,name=segments" json:"segments,omitempty"`
	// Signature of the hash of the concatenated hashes
	Sig []byte `protobuf:"bytes,2,opt,name=sig,proto3" json:"sig,omitempty"`
}

func (m *TranscodeData) Reset()                    { *m = TranscodeData{} }
func (m *TranscodeData) String() string            { return proto.CompactTextString(m) }
func (*TranscodeData) ProtoMessage()               {}
func (*TranscodeData) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *TranscodeData) GetSegments() []*TranscodedSegmentData {
	if m != nil {
		return m.Segments
	}
	return nil
}

func (m *TranscodeData) GetSig() []byte {
	if m != nil {
		return m.Sig
	}
	return nil
}

// Response that a transcoder sends after transcoding a segment.
type TranscodeResult struct {
	// Sequence number of the transcoded results.
	Seq int64 `protobuf:"varint,1,opt,name=seq" json:"seq,omitempty"`
	// Result of transcoding can be an error, or successful with more info
	//
	// Types that are valid to be assigned to Result:
	//	*TranscodeResult_Error
	//	*TranscodeResult_Data
	Result isTranscodeResult_Result `protobuf_oneof:"result"`
}

func (m *TranscodeResult) Reset()                    { *m = TranscodeResult{} }
func (m *TranscodeResult) String() string            { return proto.CompactTextString(m) }
func (*TranscodeResult) ProtoMessage()               {}
func (*TranscodeResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

type isTranscodeResult_Result interface{ isTranscodeResult_Result() }

type TranscodeResult_Error struct {
	Error string `protobuf:"bytes,2,opt,name=error,oneof"`
}
type TranscodeResult_Data struct {
	Data *TranscodeData `protobuf:"bytes,3,opt,name=data,oneof"`
}

func (*TranscodeResult_Error) isTranscodeResult_Result() {}
func (*TranscodeResult_Data) isTranscodeResult_Result()  {}

func (m *TranscodeResult) GetResult() isTranscodeResult_Result {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *TranscodeResult) GetSeq() int64 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *TranscodeResult) GetError() string {
	if x, ok := m.GetResult().(*TranscodeResult_Error); ok {
		return x.Error
	}
	return ""
}

func (m *TranscodeResult) GetData() *TranscodeData {
	if x, ok := m.GetResult().(*TranscodeResult_Data); ok {
		return x.Data
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*TranscodeResult) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _TranscodeResult_OneofMarshaler, _TranscodeResult_OneofUnmarshaler, _TranscodeResult_OneofSizer, []interface{}{
		(*TranscodeResult_Error)(nil),
		(*TranscodeResult_Data)(nil),
	}
}

func _TranscodeResult_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*TranscodeResult)
	// result
	switch x := m.Result.(type) {
	case *TranscodeResult_Error:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Error)
	case *TranscodeResult_Data:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Data); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("TranscodeResult.Result has unexpected type %T", x)
	}
	return nil
}

func _TranscodeResult_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*TranscodeResult)
	switch tag {
	case 2: // result.error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Result = &TranscodeResult_Error{x}
		return true, err
	case 3: // result.data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TranscodeData)
		err := b.DecodeMessage(msg)
		m.Result = &TranscodeResult_Data{msg}
		return true, err
	default:
		return false, nil
	}
}

func _TranscodeResult_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*TranscodeResult)
	// result
	switch x := m.Result.(type) {
	case *TranscodeResult_Error:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Error)))
		n += len(x.Error)
	case *TranscodeResult_Data:
		s := proto.Size(x.Data)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Sent by the transcoder to register itself to the orchestrator.
type RegisterRequest struct {
	// Shared secret for auth
	Secret string `protobuf:"bytes,1,opt,name=secret" json:"secret,omitempty"`
	// Transcoder capacity
	Capacity int64 `protobuf:"varint,2,opt,name=capacity" json:"capacity,omitempty"`
}

func (m *RegisterRequest) Reset()                    { *m = RegisterRequest{} }
func (m *RegisterRequest) String() string            { return proto.CompactTextString(m) }
func (*RegisterRequest) ProtoMessage()               {}
func (*RegisterRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *RegisterRequest) GetSecret() string {
	if m != nil {
		return m.Secret
	}
	return ""
}

func (m *RegisterRequest) GetCapacity() int64 {
	if m != nil {
		return m.Capacity
	}
	return 0
}

// Sent by the orchestrator to the transcoder
type NotifySegment struct {
	Url      string `protobuf:"bytes,1,opt,name=url" json:"url,omitempty"`
	TaskId   int64  `protobuf:"varint,16,opt,name=taskId" json:"taskId,omitempty"`
	Profiles []byte `protobuf:"bytes,17,opt,name=profiles,proto3" json:"profiles,omitempty"`
}

func (m *NotifySegment) Reset()                    { *m = NotifySegment{} }
func (m *NotifySegment) String() string            { return proto.CompactTextString(m) }
func (*NotifySegment) ProtoMessage()               {}
func (*NotifySegment) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *NotifySegment) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *NotifySegment) GetTaskId() int64 {
	if m != nil {
		return m.TaskId
	}
	return 0
}

func (m *NotifySegment) GetProfiles() []byte {
	if m != nil {
		return m.Profiles
	}
	return nil
}

// Required parameters for probabilistic micropayment tickets
type TicketParams struct {
	// ETH address of the recipient
	Recipient []byte `protobuf:"bytes,1,opt,name=recipient,proto3" json:"recipient,omitempty"`
	// Pay out (in Wei) to the recipient if the ticket wins
	FaceValue []byte `protobuf:"bytes,2,opt,name=face_value,json=faceValue,proto3" json:"face_value,omitempty"`
	// Probability that the ticket wins
	WinProb []byte `protobuf:"bytes,3,opt,name=win_prob,json=winProb,proto3" json:"win_prob,omitempty"`
	// 32 byte keccak-256 hash commitment to a random number provided
	// by the recipient
	RecipientRandHash []byte `protobuf:"bytes,4,opt,name=recipient_rand_hash,json=recipientRandHash,proto3" json:"recipient_rand_hash,omitempty"`
	// Value generated by recipient that the recipient can use
	// to derive the random number corresponding to the recipient's hash commitment
	Seed []byte `protobuf:"bytes,5,opt,name=seed,proto3" json:"seed,omitempty"`
}

func (m *TicketParams) Reset()                    { *m = TicketParams{} }
func (m *TicketParams) String() string            { return proto.CompactTextString(m) }
func (*TicketParams) ProtoMessage()               {}
func (*TicketParams) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *TicketParams) GetRecipient() []byte {
	if m != nil {
		return m.Recipient
	}
	return nil
}

func (m *TicketParams) GetFaceValue() []byte {
	if m != nil {
		return m.FaceValue
	}
	return nil
}

func (m *TicketParams) GetWinProb() []byte {
	if m != nil {
		return m.WinProb
	}
	return nil
}

func (m *TicketParams) GetRecipientRandHash() []byte {
	if m != nil {
		return m.RecipientRandHash
	}
	return nil
}

func (m *TicketParams) GetSeed() []byte {
	if m != nil {
		return m.Seed
	}
	return nil
}

// Probabilistic micropayment ticket
type Ticket struct {
	// ETH address of the recipient
	Recipient []byte `protobuf:"bytes,1,opt,name=recipient,proto3" json:"recipient,omitempty"`
	// ETH address of the sender
	Sender []byte `protobuf:"bytes,2,opt,name=sender,proto3" json:"sender,omitempty"`
	// Pay out (in Wei) to the recipient if the ticket wins
	FaceValue []byte `protobuf:"bytes,3,opt,name=face_value,json=faceValue,proto3" json:"face_value,omitempty"`
	// Probability that the ticket wins
	WinProb []byte `protobuf:"bytes,4,opt,name=win_prob,json=winProb,proto3" json:"win_prob,omitempty"`
	// Monotonically increasing counter that makes the ticket
	// unique relative to a particular hash commitment to a recipient's random number
	SenderNonce uint32 `protobuf:"varint,5,opt,name=sender_nonce,json=senderNonce" json:"sender_nonce,omitempty"`
	// 32 byte keccak-256 hash commitment to a random number provided
	// by the recipient
	RecipientRandHash []byte `protobuf:"bytes,6,opt,name=recipient_rand_hash,json=recipientRandHash,proto3" json:"recipient_rand_hash,omitempty"`
}

func (m *Ticket) Reset()                    { *m = Ticket{} }
func (m *Ticket) String() string            { return proto.CompactTextString(m) }
func (*Ticket) ProtoMessage()               {}
func (*Ticket) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *Ticket) GetRecipient() []byte {
	if m != nil {
		return m.Recipient
	}
	return nil
}

func (m *Ticket) GetSender() []byte {
	if m != nil {
		return m.Sender
	}
	return nil
}

func (m *Ticket) GetFaceValue() []byte {
	if m != nil {
		return m.FaceValue
	}
	return nil
}

func (m *Ticket) GetWinProb() []byte {
	if m != nil {
		return m.WinProb
	}
	return nil
}

func (m *Ticket) GetSenderNonce() uint32 {
	if m != nil {
		return m.SenderNonce
	}
	return 0
}

func (m *Ticket) GetRecipientRandHash() []byte {
	if m != nil {
		return m.RecipientRandHash
	}
	return nil
}

// Payment for transcoding video segments
// A payment can constitute of multiple tickets
// A broadcaster might need to send multiple tickets to top up his credit with an Orchestrator
type Payment struct {
	// Probabilistic micropayment ticket
	Tickets []*Ticket `protobuf:"bytes,1,rep,name=tickets" json:"tickets,omitempty"`
	// Sender signature over the ticket
	Sigs [][]byte `protobuf:"bytes,2,rep,name=sigs,proto3" json:"sigs,omitempty"`
	// Value generated by recipient that the recipient can use
	// to derive the random number corresponding to the recipient's hash commitment
	Seeds [][]byte `protobuf:"bytes,3,rep,name=seeds,proto3" json:"seeds,omitempty"`
}

func (m *Payment) Reset()                    { *m = Payment{} }
func (m *Payment) String() string            { return proto.CompactTextString(m) }
func (*Payment) ProtoMessage()               {}
func (*Payment) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *Payment) GetTickets() []*Ticket {
	if m != nil {
		return m.Tickets
	}
	return nil
}

func (m *Payment) GetSigs() [][]byte {
	if m != nil {
		return m.Sigs
	}
	return nil
}

func (m *Payment) GetSeeds() [][]byte {
	if m != nil {
		return m.Seeds
	}
	return nil
}

func init() {
	proto.RegisterType((*PingPong)(nil), "net.PingPong")
	proto.RegisterType((*OrchestratorRequest)(nil), "net.OrchestratorRequest")
	proto.RegisterType((*OSInfo)(nil), "net.OSInfo")
	proto.RegisterType((*S3OSInfo)(nil), "net.S3OSInfo")
	proto.RegisterType((*OrchestratorInfo)(nil), "net.OrchestratorInfo")
	proto.RegisterType((*SegData)(nil), "net.SegData")
	proto.RegisterType((*TranscodedSegmentData)(nil), "net.TranscodedSegmentData")
	proto.RegisterType((*TranscodeData)(nil), "net.TranscodeData")
	proto.RegisterType((*TranscodeResult)(nil), "net.TranscodeResult")
	proto.RegisterType((*RegisterRequest)(nil), "net.RegisterRequest")
	proto.RegisterType((*NotifySegment)(nil), "net.NotifySegment")
	proto.RegisterType((*TicketParams)(nil), "net.TicketParams")
	proto.RegisterType((*Ticket)(nil), "net.Ticket")
	proto.RegisterType((*Payment)(nil), "net.Payment")
	proto.RegisterEnum("net.OSInfo_StorageType", OSInfo_StorageType_name, OSInfo_StorageType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Orchestrator service

type OrchestratorClient interface {
	// Called by the broadcaster to request transcoder info from an orchestrator.
	GetOrchestrator(ctx context.Context, in *OrchestratorRequest, opts ...grpc.CallOption) (*OrchestratorInfo, error)
	Ping(ctx context.Context, in *PingPong, opts ...grpc.CallOption) (*PingPong, error)
}

type orchestratorClient struct {
	cc *grpc.ClientConn
}

func NewOrchestratorClient(cc *grpc.ClientConn) OrchestratorClient {
	return &orchestratorClient{cc}
}

func (c *orchestratorClient) GetOrchestrator(ctx context.Context, in *OrchestratorRequest, opts ...grpc.CallOption) (*OrchestratorInfo, error) {
	out := new(OrchestratorInfo)
	err := grpc.Invoke(ctx, "/net.Orchestrator/GetOrchestrator", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orchestratorClient) Ping(ctx context.Context, in *PingPong, opts ...grpc.CallOption) (*PingPong, error) {
	out := new(PingPong)
	err := grpc.Invoke(ctx, "/net.Orchestrator/Ping", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Orchestrator service

type OrchestratorServer interface {
	// Called by the broadcaster to request transcoder info from an orchestrator.
	GetOrchestrator(context.Context, *OrchestratorRequest) (*OrchestratorInfo, error)
	Ping(context.Context, *PingPong) (*PingPong, error)
}

func RegisterOrchestratorServer(s *grpc.Server, srv OrchestratorServer) {
	s.RegisterService(&_Orchestrator_serviceDesc, srv)
}

func _Orchestrator_GetOrchestrator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrchestratorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrchestratorServer).GetOrchestrator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/net.Orchestrator/GetOrchestrator",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrchestratorServer).GetOrchestrator(ctx, req.(*OrchestratorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Orchestrator_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PingPong)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrchestratorServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/net.Orchestrator/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrchestratorServer).Ping(ctx, req.(*PingPong))
	}
	return interceptor(ctx, in, info, handler)
}

var _Orchestrator_serviceDesc = grpc.ServiceDesc{
	ServiceName: "net.Orchestrator",
	HandlerType: (*OrchestratorServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetOrchestrator",
			Handler:    _Orchestrator_GetOrchestrator_Handler,
		},
		{
			MethodName: "Ping",
			Handler:    _Orchestrator_Ping_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "net/lp_rpc.proto",
}

// Client API for Transcoder service

type TranscoderClient interface {
	// Called by the transcoder to register to an orchestrator. The orchestrator
	// notifies registered transcoders of segments as they come in.
	RegisterTranscoder(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (Transcoder_RegisterTranscoderClient, error)
}

type transcoderClient struct {
	cc *grpc.ClientConn
}

func NewTranscoderClient(cc *grpc.ClientConn) TranscoderClient {
	return &transcoderClient{cc}
}

func (c *transcoderClient) RegisterTranscoder(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (Transcoder_RegisterTranscoderClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Transcoder_serviceDesc.Streams[0], c.cc, "/net.Transcoder/RegisterTranscoder", opts...)
	if err != nil {
		return nil, err
	}
	x := &transcoderRegisterTranscoderClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Transcoder_RegisterTranscoderClient interface {
	Recv() (*NotifySegment, error)
	grpc.ClientStream
}

type transcoderRegisterTranscoderClient struct {
	grpc.ClientStream
}

func (x *transcoderRegisterTranscoderClient) Recv() (*NotifySegment, error) {
	m := new(NotifySegment)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Transcoder service

type TranscoderServer interface {
	// Called by the transcoder to register to an orchestrator. The orchestrator
	// notifies registered transcoders of segments as they come in.
	RegisterTranscoder(*RegisterRequest, Transcoder_RegisterTranscoderServer) error
}

func RegisterTranscoderServer(s *grpc.Server, srv TranscoderServer) {
	s.RegisterService(&_Transcoder_serviceDesc, srv)
}

func _Transcoder_RegisterTranscoder_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RegisterRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TranscoderServer).RegisterTranscoder(m, &transcoderRegisterTranscoderServer{stream})
}

type Transcoder_RegisterTranscoderServer interface {
	Send(*NotifySegment) error
	grpc.ServerStream
}

type transcoderRegisterTranscoderServer struct {
	grpc.ServerStream
}

func (x *transcoderRegisterTranscoderServer) Send(m *NotifySegment) error {
	return x.ServerStream.SendMsg(m)
}

var _Transcoder_serviceDesc = grpc.ServiceDesc{
	ServiceName: "net.Transcoder",
	HandlerType: (*TranscoderServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "RegisterTranscoder",
			Handler:       _Transcoder_RegisterTranscoder_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "net/lp_rpc.proto",
}

func init() { proto.RegisterFile("net/lp_rpc.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 872 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x55, 0xdd, 0x6e, 0x23, 0x35,
	0x14, 0xee, 0x74, 0xd2, 0x49, 0x7a, 0x92, 0xd0, 0xd4, 0xbb, 0x5b, 0x86, 0x08, 0x56, 0x61, 0x44,
	0xa5, 0x72, 0x13, 0x50, 0x2a, 0x2d, 0xe2, 0x8e, 0x5d, 0x5a, 0xda, 0x48, 0xa8, 0x8d, 0x9c, 0x80,
	0x04, 0x37, 0x91, 0x3b, 0xe3, 0x4c, 0xad, 0xa6, 0x9e, 0x59, 0xdb, 0x61, 0x37, 0xbc, 0x05, 0xaf,
	0x00, 0x5c, 0xf1, 0x2a, 0xbc, 0x14, 0xf2, 0xf1, 0xcc, 0x64, 0xb2, 0xdd, 0x02, 0x77, 0x3e, 0xdf,
	0xf1, 0xcf, 0xe7, 0xcf, 0xdf, 0x39, 0x86, 0x9e, 0xe4, 0xe6, 0x8b, 0x65, 0x3e, 0x57, 0x79, 0x3c,
	0xcc, 0x55, 0x66, 0x32, 0xe2, 0x4b, 0x6e, 0xa2, 0x01, 0xb4, 0x26, 0x42, 0xa6, 0x93, 0x4c, 0xa6,
	0xe4, 0x29, 0xec, 0xfd, 0xc2, 0x96, 0x2b, 0x1e, 0x7a, 0x03, 0xef, 0xa4, 0x43, 0x5d, 0x10, 0xbd,
	0x84, 0x27, 0xd7, 0x2a, 0xbe, 0xe5, 0xda, 0x28, 0x66, 0x32, 0x45, 0xf9, 0xeb, 0x15, 0xd7, 0x86,
	0x84, 0xd0, 0x64, 0x49, 0xa2, 0xb8, 0xd6, 0xc5, 0xf4, 0x32, 0x24, 0x3d, 0xf0, 0xb5, 0x48, 0xc3,
	0x5d, 0x44, 0xed, 0x30, 0xfa, 0xc3, 0x83, 0xe0, 0x7a, 0x3a, 0x96, 0x8b, 0x8c, 0x7c, 0x0d, 0x6d,
	0x6d, 0x32, 0xc5, 0x52, 0x3e, 0x5b, 0xe7, 0xee, 0xa4, 0x0f, 0x46, 0x1f, 0x0e, 0x25, 0x37, 0x43,
	0x37, 0x63, 0x38, 0xdd, 0xa4, 0x69, 0x7d, 0x2e, 0x39, 0x86, 0x40, 0x9f, 0x0a, 0xb9, 0xc8, 0xc2,
	0xde, 0xc0, 0x3b, 0x69, 0x8f, 0xba, 0xb8, 0x6a, 0x7a, 0xea, 0xd6, 0xd1, 0x22, 0x19, 0x7d, 0x05,
	0xed, 0xda, 0x16, 0x04, 0x20, 0x38, 0x1b, 0xd3, 0xf3, 0x6f, 0x67, 0xbd, 0x1d, 0x12, 0xc0, 0xee,
	0xf4, 0xb4, 0xe7, 0x91, 0x16, 0x34, 0xc6, 0x93, 0xef, 0xa6, 0xbd, 0x5d, 0x9b, 0xbd, 0xb8, 0xbe,
	0xbe, 0xf8, 0xfe, 0xbc, 0xe7, 0x47, 0xbf, 0x7b, 0xd0, 0x2a, 0x77, 0x23, 0x04, 0x1a, 0xb7, 0x99,
	0x36, 0x48, 0x70, 0x9f, 0xe2, 0xd8, 0x5e, 0xec, 0x8e, 0xaf, 0xf1, 0x62, 0xfb, 0xd4, 0x0e, 0xc9,
	0x11, 0x04, 0x79, 0xb6, 0x14, 0xf1, 0x3a, 0xf4, 0x11, 0x2c, 0x22, 0xf2, 0x31, 0xec, 0x6b, 0x91,
	0x4a, 0x66, 0x56, 0x8a, 0x87, 0x0d, 0x4c, 0x6d, 0x00, 0xf2, 0x1c, 0x20, 0x56, 0x3c, 0xe1, 0xd2,
	0x08, 0xb6, 0x0c, 0xf7, 0x30, 0x5d, 0x43, 0x48, 0x1f, 0x5a, 0x6f, 0x5f, 0xde, 0xff, 0x7a, 0xc6,
	0x0c, 0x0f, 0x03, 0xcc, 0x56, 0x71, 0xf4, 0x9b, 0x07, 0xbd, 0xfa, 0x73, 0x20, 0xd9, 0xe7, 0x00,
	0x46, 0x31, 0xa9, 0xe3, 0x2c, 0xe1, 0xaa, 0xa0, 0x5c, 0x43, 0xc8, 0x0b, 0xe8, 0x1a, 0x11, 0xdf,
	0x71, 0x33, 0xcf, 0x99, 0x62, 0xf7, 0x1a, 0xaf, 0xd0, 0x1e, 0x1d, 0xa2, 0x80, 0x33, 0xcc, 0x4c,
	0x30, 0x41, 0x3b, 0xa6, 0x16, 0x91, 0x63, 0x68, 0x16, 0x0f, 0x10, 0x0e, 0x06, 0xfe, 0x49, 0x7b,
	0xd4, 0xae, 0x3d, 0x14, 0x2d, 0x73, 0xd1, 0x9f, 0x1e, 0x34, 0xa7, 0x3c, 0x3d, 0x63, 0x86, 0x59,
	0x2a, 0xf7, 0x4c, 0x8a, 0x05, 0xd7, 0x66, 0x9c, 0x14, 0xce, 0xa8, 0x21, 0x68, 0x0e, 0xfe, 0x1a,
	0x09, 0xf8, 0xd4, 0x0e, 0x51, 0x69, 0xa6, 0x6f, 0x51, 0xc1, 0x0e, 0xc5, 0xb1, 0x55, 0x20, 0x57,
	0xd9, 0x42, 0x2c, 0xb9, 0x46, 0xf9, 0x3a, 0xb4, 0x8a, 0x4b, 0x7b, 0xed, 0x55, 0xf6, 0xfa, 0xbf,
	0x34, 0x3f, 0x87, 0x67, 0xb3, 0x52, 0x93, 0x64, 0xca, 0xd3, 0x7b, 0x2e, 0x0d, 0x72, 0xee, 0x81,
	0xbf, 0x52, 0xcb, 0x42, 0x37, 0x3b, 0x8c, 0x7e, 0x82, 0x6e, 0x35, 0x15, 0xa7, 0xbc, 0x80, 0x96,
	0x76, 0x2b, 0xac, 0xdd, 0xed, 0x19, 0x7d, 0x27, 0xde, 0xfb, 0x36, 0xa4, 0xd5, 0xdc, 0xf7, 0xd4,
	0x42, 0x06, 0x07, 0xd5, 0x22, 0xca, 0xf5, 0x6a, 0x69, 0x4a, 0x4d, 0xbc, 0x8d, 0x26, 0x47, 0xb0,
	0xc7, 0x95, 0xca, 0x94, 0xf3, 0xda, 0xe5, 0x0e, 0x75, 0x21, 0x39, 0x81, 0x46, 0xc2, 0x0c, 0x43,
	0xad, 0xda, 0x23, 0xb2, 0x4d, 0xc1, 0x1e, 0x7d, 0xb9, 0x43, 0x71, 0xc6, 0xab, 0x16, 0x04, 0x0a,
	0x77, 0x8f, 0xce, 0xe1, 0x80, 0xf2, 0x54, 0x68, 0xc3, 0xab, 0xda, 0x3d, 0x82, 0x40, 0xf3, 0x58,
	0xf1, 0xd2, 0xde, 0x45, 0x64, 0x65, 0x8f, 0x59, 0xce, 0x62, 0x61, 0xd6, 0xc5, 0x0b, 0x55, 0x71,
	0xf4, 0x03, 0x74, 0xaf, 0x32, 0x23, 0x16, 0xeb, 0xe2, 0xa2, 0x0f, 0x55, 0xb3, 0xdb, 0x1a, 0xa6,
	0xef, 0xc6, 0x09, 0x16, 0xa8, 0x4f, 0x8b, 0x68, 0xeb, 0x35, 0x0f, 0xb7, 0x5f, 0x33, 0xfa, 0xcb,
	0x83, 0x4e, 0xdd, 0x81, 0xb6, 0x74, 0x14, 0x8f, 0x45, 0x2e, 0xb8, 0x34, 0x85, 0x7f, 0x36, 0x00,
	0xf9, 0x04, 0x60, 0xc1, 0x62, 0x3e, 0x77, 0x7d, 0xca, 0xc9, 0xba, 0x6f, 0x91, 0x1f, 0x2d, 0x40,
	0x3e, 0x82, 0xd6, 0x1b, 0x21, 0xe7, 0xb9, 0xca, 0x6e, 0x0a, 0x3f, 0x35, 0xdf, 0x08, 0x39, 0x51,
	0xd9, 0x0d, 0x19, 0xc2, 0x93, 0x6a, 0x9b, 0xb9, 0x62, 0x32, 0x99, 0xa3, 0xeb, 0x9c, 0xbb, 0x0e,
	0xab, 0x14, 0x65, 0x32, 0xb9, 0xb4, 0x16, 0x24, 0xd0, 0xd0, 0x9c, 0x27, 0x85, 0xcf, 0x70, 0x1c,
	0xfd, 0xed, 0x41, 0xe0, 0xc8, 0xfe, 0x07, 0x4d, 0x14, 0x58, 0xda, 0x62, 0x74, 0x14, 0x8b, 0xe8,
	0x1d, 0xfa, 0xfe, 0xbf, 0xd1, 0x6f, 0x6c, 0xd3, 0xff, 0x14, 0x3a, 0x6e, 0x8f, 0xb9, 0xcc, 0x64,
	0xcc, 0x91, 0x56, 0x97, 0xb6, 0x1d, 0x76, 0x65, 0xa1, 0xc7, 0x6e, 0x18, 0x3c, 0x72, 0xc3, 0xe8,
	0x67, 0x68, 0x4e, 0xd8, 0x1a, 0xdf, 0xf2, 0x18, 0x9a, 0xae, 0xf0, 0x4b, 0x77, 0xb7, 0x6b, 0xad,
	0x81, 0x96, 0x39, 0xd4, 0x44, 0xa4, 0xb6, 0x7d, 0xf8, 0xa8, 0x89, 0x48, 0xb5, 0xfd, 0x34, 0xac,
	0x36, 0x3a, 0xf4, 0x11, 0x74, 0xc1, 0xe8, 0x2d, 0x74, 0xea, 0x5d, 0x8a, 0xbc, 0x82, 0x83, 0x0b,
	0x6e, 0xb6, 0xa0, 0xd0, 0x15, 0xe9, 0xc3, 0xaf, 0xa5, 0xff, 0xec, 0x41, 0x06, 0xbb, 0xdc, 0x67,
	0xd0, 0xb0, 0x5f, 0x15, 0x71, 0x7d, 0xbf, 0xfc, 0xb5, 0xfa, 0xdb, 0xe1, 0xe8, 0x0a, 0x60, 0xb6,
	0xe9, 0x7c, 0xdf, 0x00, 0x29, 0xcd, 0x5f, 0x43, 0x9f, 0xe2, 0x92, 0x77, 0xaa, 0xa2, 0xef, 0xca,
	0x69, 0xcb, 0xe4, 0x5f, 0x7a, 0x37, 0x01, 0x7e, 0x96, 0xa7, 0xff, 0x04, 0x00, 0x00, 0xff, 0xff,
	0xce, 0x53, 0x6e, 0x7f, 0x40, 0x07, 0x00, 0x00,
}
